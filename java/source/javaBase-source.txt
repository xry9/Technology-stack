public class java.lang.Thread implements Runnable {
	private volatile Interruptible blocker;
    public void interrupt() {
        if (this != Thread.currentThread()) checkAccess();
        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }
    public static boolean interrupted() { return currentThread().isInterrupted(true); }// 所以这个方法最好别用了, 不灵活
    public boolean isInterrupted() { return isInterrupted(false); }
    private native boolean isInterrupted(boolean ClearInterrupted);
	private native void interrupt0();
	public static native void sleep(long millis) throws InterruptedException;
	public final native boolean isAlive(); // start 之前不是 alive
}
public interface sun.nio.ch.Interruptible { // 实现类就 nio 中有两个
    void interrupt(Thread var1);
}
经测试 可以当普通方法来用, 即通过线程对象来调, 不必非要在 run 方法中 intercept()/Thread.currThread.intercept(), 但是要在 start 之后
Thread thread = new MyInerruptThread();thread.interrupt();

在 sleep 期间或 sleep 之前调用 interrupt, sleep 时都会 InterruptedException, 当然异常之后 isInterrupted() 失效, 当遇到 wait(); 时完全一样
isInterrupted() 也可以在外面调用的 thread.isInterrupted(), 而且不会清除状态, 当然他遇到 sleep/wait 是没有问题的
Lock 中 UNSAFE.park 不会抛出 InterruptedException, 所以 lock.lock(); 得到锁会也不必太担心 intercept 操作

================================ ThreadLocal ================================
// ThreadLocal 通常做为某个类的静态变量使用
public class ThreadLocal<T> {
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
			// 从这里就能看出 ThreadLocal 与 Thread 是多对多关系,key 分别是自身. 即每个 ThreadLocal 挂着很多 Thread, 每个 Thread 也可以挂着多个 ThreadLocal
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
	public void set(T value) {
		Thread t = Thread.currentThread();
		ThreadLocalMap map = getMap(t);
		if (map != null)
			map.set(this, value);
		else
			createMap(t, value);
	}
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
	void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }
	static class ThreadLocalMap {
		private Entry getEntry(ThreadLocal<?> key) {
            int i = key.threadLocalHashCode & (table.length - 1);
            Entry e = table[i];
            if (e != null && e.get() == key) return e;
            else return getEntryAfterMiss(key, i, e);
        }
		private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) {
            Entry[] tab = table;
            int len = tab.length;
            while (e != null) { // e != null 表示 WeakReference 起了作用
                ThreadLocal k = e.get();
                if (k == key) return e;
                if (k == null) expungeStaleEntry(i);// 清除 entry
                else i = nextIndex(i, len);// 怎么还会有这种情况呢
                e = tab[i];
            }
            return null;
        }
		private void set(ThreadLocal key, Object value) {
            tab[i] = new Entry(key, value);
            int sz = ++size;
            if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash();// 每次 set 都要 cleanSomeSlots 一下，把 key 为 null 的 Entry 置 null, 确如其名只是 some, 并不是扫描整个 table
        }
		static class Entry extends WeakReference<ThreadLocal<?>> { // 挺奇怪的 key 是个弱引用, value 不是
            Object value;
            Entry(ThreadLocal<?> k, Object v) { super(k); value = v; }
        }
	}
}
public class Thread implements Runnable {
	ThreadLocal.ThreadLocalMap threadLocals = null;
}
结论: ThreadLocal 与 Thread 是多对多关系,key 分别是自身
ThreadLocal 明显的问题是内存泄露, 即不断有新线程产生, 还有就是线程池问题, 数据错误。话又说回来了, ThreadLocal 用那么恶心的数据结构应该
就是为了解决线程下线过多这个问题的, 而把 Entry 设计成 WeakReference 应该是防止 ThreadLocal 过多下线才这样设计的吧, 但是这样设计是有风险
的如果用的人不知道

  显示指定 ThreadLocalRef = null 时则如下[X], 所以别忘了只要 tl 的引用还有 Entry 虽是弱引用但不会清数据。value 如果不是因为弱引用则是
无法被回收的, 这也就是内存泄露的原因
								|---------------------------------------|
								|							|-------|	|
|-------------------|           |							| value	|---|-> 100M
|	threadLocalRef	| ---X---->	|	ThreadLocal	 <----X----	|  Key	|	|
|					|			|					---->	|-------|	|
|					|			|					|		  Entry		|
|	threadRef		|-------->	|	Thread --> ThreadLocalMap			|
|-------------------|			|---------------------------------------|

1. tl = null; 前做一下 tl.set(null);当然 tl.remove(); 更好, 其实最重要的是 remove, remove 之后 t1 与普通对象无异, 置不置 null 全凭心情
  其实以引申一下, 什么情况下要对引用显式置 null, 就是那种常住内存对象的属性吧
2. 线程运行结束后及时线程引用置 null (但是怎样确定是否运行结束是不可能的吧，只有要 run 结束之前标识用其它变量来标识一下)
3. 总结一下 TL 一切问题的根源是, 一个对象存在显示和隐式两个引入, 显示引用断开了之后隐式隐用就不能断开(因为确定不了可以可以断开), 造成了内存泄露
  其实想想我用 HashMap 时考虑过内存泄露问题么, 但是通常又没什么问题, 应该是因为我用的场景都不是一个常住内存的 Map, 要么内存不够直接 oom了, 
  不存在内存泄露问题, 所以说 TL 有这问题也不奇怪, 常住内存的 Map 都有这问题, 例如 datanode.fsdataset.impl.ReplicaMap#map 中的这种用法是有 remove 的
4. 我突然懂了为什么要把 ThreadLocalMap 放在 Thread 中, 如果放在 ThreadLocal(Thread 做 key) 或者 单独存在(这种其实最省空间), 但是无法做到 remove, 
因为不知道线程什么时候执行完, 现在这样设计虽然很蹩脚, 但是只要用的好是可以规避风险的(能不能让每个线程都 remove 也得看情况了)
--------
分析: 首先应想到的是 Map 放在哪, Map 的 key 是啥
a. Map 放在外面的话,在 ThreadLocal 内即可, key 就是线程, 数据没有冗余, 问题是线程销毁有内存泄露, 但是我觉得应该有办法挽救吧, 但是肯定很不容易
b. Map 放在 Thread 里, 也没有数据冗余, 也有内存泄露风险, ThreadLocal 对象不好回收, 但是处理得当应该没问题
c. 所以结果是 b 方案更好
5. 我认为 ThreadLocal 使用场景的话就是类 session, 在 server 记录 client 用户信息

================================ Thread 提交 ================================
1、多线程异步调用有一个成功怎样让其它结束, 应该是成功的线程将其它都 intercept 一下, 我突然理解了 hbase client 采用两级线程的新的好处了, 
而线程的 run/call 方法内 while 并跟据 intercept 状态 break;

2、java.util.concurrent.FutureTask#cancel 这方法是什么鬼

1、关 connection 时, 线程 intercept 了, 遇到 wait 会结束, 但是内部的 socket 没有 close 会有问题吗, 放心 catch 里会捕获 InterruptedException, 然后去...
  socket io 阻塞时 intercept 不会出现 InterruptedException
2、线程池 shutdown 时会把每个线程都 interrupt 一下, 

public interface Runnable {
    public abstract void run();
}
public class Thread implements Runnable {
    private Runnable target;
    public void run() {
        if (target != null) { target.run(); }
    }
    public static native Thread currentThread();
}
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)throws InterruptedException, ExecutionException, TimeoutException;
}
public interface RunnableFuture<V> extends Runnable, Future<V> {
}
public interface Callable<V> {
    V call() throws Exception;
}
public interface Executor {
    void execute(Runnable command);
}
public interface ExecutorService extends Executor {
    void shutdown();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    <T> Future<T> submit(Callable<T> task);
	// 好像没什么意义,因为 Runnable 的 run 方法是 void 
    Future<?> submit(Runnable task);
}
public abstract class AbstractExecutorService implements ExecutorService {
    public Future<?> submit(Runnable task) {
        RunnableFuture<Void> ftask = newTaskFor(task, null);
		// 从此以后与 pool.execute(Runnable command) 的逻辑完全相同了
        execute(ftask);
        return ftask;
    }
    public <T> Future<T> submit(Callable<T> task) {
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }
    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        return new FutureTask<T>(callable);
    }
}
public class ThreadPoolExecutor extends AbstractExecutorService {
	public void execute(Runnable command) {
		if (addWorker(command, true)) return;
	}
	private boolean addWorker(Runnable firstTask, boolean core) {
        Worker w = new Worker(firstTask);
		// w.thread 本质上是对 firstTask 包了一层
		final Thread t = w.thread;
		workers.add(w);
		workerAdded = true;
		if (workerAdded) {
			t.start();
			workerStarted = true;
		}
        return workerStarted;
    }	
	private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
        final Thread thread;
        Runnable firstTask;
        volatile long completedTasks;
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);// 这里是真正创建线程了, 而传入了一个 runnable 则调 start() 时自然就走此类的 run()
        }
        public void run() {
            runWorker(this);
        }
    }
	final void runWorker(Worker w) {
		try{
			// getTask() 可以认为是去一个阻塞队列里取 task 了
			while (task != null || (task = getTask()) != null) {
				Runnable task = w.firstTask;
				task.run();
			}
		}finally {
			// 讨论一下线程池运行原理,这里只是推测,不代表结论. 线程池的活跃线程数即上面 start 的次数,而 processWorkerExit 方法执行表示线程
			// 运行结束, 如不执行 pool.shutdown(); 则 processWorkerExit 就不会执行,没有结束的线程去 getTask() 了. 
			// 线程池本身并不会启动一个线程管理池的运行,这是我之前的误判
            processWorkerExit(w, completedAbruptly);// 走到这 worker 及所对应的 Thread 就结束了, 线程数降到核心线程数就是这么实现的
        }
    }
	private Runnable getTask() {
		boolean timedOut = false; // Did the last poll() time out?
		for (;;) {
			int c = ctl.get();
			int rs = runStateOf(c);
			// 如果已经大于 SHUTDOWN,即有可能 STOP, 并且队列 isEmpty 或者 STOP 则返回空, 不会阻塞(多说一句, shutdownNow 很厉害, 直接把 state 变为 STOP, 队列有 task 也不处理了)
			if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
				decrementWorkerCount();// 对应的 worker 可以结束了所以 -1
				return null;
			}
			int wc = workerCountOf(c);
			boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
			if ((wc > maximumPoolSize || (timed && timedOut)) && (wc > 1 || workQueue.isEmpty())) {
				if (compareAndDecrementWorkerCount(c)) return null;// 如果 worker 数大于 corePoolSize 且 workQueue isEmpty 则返回 null, worker 就会线束
				continue;
			}
			try {
				Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();// 线程池之后以阻塞不关闭就是通过 take 表现的
				if (r != null) return r;
				timedOut = true;
			} catch (InterruptedException retry) { timedOut = false; }
		}
	}
}
public class FutureTask<V> implements RunnableFuture<V> {
    private Callable<V> callable;
    private volatile Thread runner;
	private Object outcome; // non-volatile, protected by state reads/writes
    private volatile WaitNode waiters;

    private V report(int s) throws ExecutionException {
        Object x = outcome;
        if (s == NORMAL) return (V)x;
    }
    public V get() throws InterruptedException, ExecutionException {
        int s = state;
        if (s <= COMPLETING) s = awaitDone(false, 0L);// LockSupport.park LockSupport.parkNanos
        return report(s);
    }
    public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        int s = state;
        if (s <= COMPLETING && (s = awaitDone(true, unit.toNanos(timeout))) <= COMPLETING) throw new TimeoutException();
        return report(s);
    }
    public FutureTask(Callable<V> callable) {
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }
    public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // ensure visibility of callable
    }
    public void run() {
		Callable<V> c = callable;
		V result; boolean ran;
		result = c.call();
		ran = true;
		if (ran) set(result);
    }
    protected void set(V v) {
		if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
            outcome = v;
            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // JDK会在执行这三个方法时插入 StoreStore 内存屏障，避免发生写操作重排序
            finishCompletion();
        }
    }
	// 调用 get() 会进到 awaitDone 里来, 产生一个 WaitNode, 形成一个阻塞线程的链表, finishCompletion 时会依次释放链表
	private int awaitDone(boolean timed, long nanos) throws InterruptedException {
        final long deadline = timed ? System.nanoTime() + nanos : 0L;
        WaitNode q = null;
        boolean queued = false;
        for (;;) {
            int s = state;
            if (s > COMPLETING) {
                if (q != null) q.thread = null;
                return s;
            }else if (s == COMPLETING) Thread.yield();
            else if (q == null) q = new WaitNode();
            else if (!queued) queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q);
            else if (timed) {
                nanos = deadline - System.nanoTime();
                if (nanos <= 0L) {
                    removeWaiter(q);
                    return state;
                }
                LockSupport.parkNanos(this, nanos);
            }else LockSupport.park(this);
        }
    }
	private void finishCompletion() {
        for (WaitNode q; (q = waiters) != null;) {
            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {
                for (;;) {
                    Thread t = q.thread;
                    if (t != null) {
                        q.thread = null;
                        LockSupport.unpark(t);// 释放链表中阻塞的线程
                    }
                    WaitNode next = q.next;
                    if (next == null) break;
                    q.next = null; // unlink to help gc
                    q = next;
                }
                break;
            }
        }
        done();// 这个方法可以重写一下子啊, 回调 
        callable = null;        // to reduce footprint
    }
	static final class WaitNode {
		volatile Thread thread;
		volatile WaitNode next;
		WaitNode() { thread = Thread.currentThread(); }
	}
}
public class Executors {
    public static <T> Callable<T> callable(Runnable task, T result) {
        return new RunnableAdapter<T>(task, result);
    }
    static final class RunnableAdapter<T> implements Callable<T> {// 这岂不是个适配器模式
        final Runnable task;
        final T result;
        RunnableAdapter(Runnable task, T result) {
            this.task = task;
            this.result = result;
        }
        public T call() {
            task.run();
            return result;
        }
    }
}
================================ Reference 提交 ================================
public abstract class Reference<T> {
    private T referent;
    volatile ReferenceQueue<? super T> queue;
    private static Reference<Object> pending = null;
    public T get() {
        return this.referent;
    }
	private static class ReferenceHandler extends Thread {
        static {...}
        ReferenceHandler(ThreadGroup g, String name) {
            super(g, name);
        }
        public void run() {
            while (true) {
                tryHandlePending(true);
            }
        }
    }
    static boolean tryHandlePending(boolean waitForNotify) {
        Reference<Object> r;
        Cleaner c;
		synchronized (lock) {// 加锁干嘛, 这不是个单线程吗
    		//pending 是 reference 能入队列的关键, 据非官方资料说 pending 值是 jvm 给的, 我也认同。更多信息源码注释部分说了好多, 如果 jvm 直接调用方法而不是通过 pending 其实不这个线程了
			if (pending != null) {
				r = pending;
				c = r instanceof Cleaner ? (Cleaner) r : null;
			} else {
				return waitForNotify;
			}
		}
        if (c != null) {
            c.clean();// 这里把堆外内存释放解释清楚了, 而且是 Cleaner 时不会加到队列里了
            return true;
        }
        ReferenceQueue<? super Object> q = r.queue;
		// 这行代码太重要，这就是往队列里添加要被回收对象的 reference 引用呀
        if (q != ReferenceQueue.NULL) q.enqueue(r);
        return true;
    }
    static {
		// ReferenceHandler 线程应该就是在这创建和 start 的，但打断点就是进不来呀
        Thread handler = new ReferenceHandler(tg, "Reference Handler");
        handler.start();
    }
	// 虚拟机启动时会创建很多 Reference 对象,构造方法可以进来
    Reference(T referent, ReferenceQueue<? super T> queue) {
        this.referent = referent;
        this.queue = (queue == null) ? ReferenceQueue.NULL : queue;
    }
}
public class SoftReference<T> extends Reference<T> {
    static private long clock;
    private long timestamp;
    public SoftReference(T referent) {
        super(referent);
        this.timestamp = clock;
    }
    public SoftReference(T referent, ReferenceQueue<? super T> q) {
        super(referent, q);
        this.timestamp = clock;
    }
    public T get() {
        T o = super.get();
        if (o != null && this.timestamp != clock)
            this.timestamp = clock;
        return o;
    }
}
public class WeakReference<T> extends Reference<T> {
    public WeakReference(T referent) {
        super(referent);
    }
    public WeakReference(T referent, ReferenceQueue<? super T> q) {
        super(referent, q);
    }
}
public class PhantomReference<T> extends Reference<T> {
    public T get() {//只有 PhantomReference 重写了 get 方法,就是让你拿不到因为能拿到的话，可以不会被置 null
        return null;
    }
    public PhantomReference(T referent, ReferenceQueue<? super T> q) {
        super(referent, q);
    }
}
public class java.lang.ref.ReferenceQueue<T> {
    private volatile Reference<? extends T> head = null;// 最重要的属性就是 head 所以认为是个链表
}

0、需要记住的是一个后台线程, 在 static 块是创建相当于全局惟一, jvm 会把回收的对象的 reference 引用传入, 此线程负责处理, 加入到创建此 reference
时传入的 queue 链表中, 所以用户想通过 queue 拿到回收的 reference 要用同一个 queue. 还有一个需要注意是如果此 reference 是 Cleaner 会调一下 clean()
这货其实也有一个 ReferenceQueue 但是跟本没有用到, 即回收后也没往 此 queue 中加入


调试几种 Reference
	0. 简单撸了一下 ReferenceQueue 这个队列的源码, 挺与众不同的，有一个 java.lang.ref.ReferenceQueue#head, next 是在这 java.lang.ref.Reference#next,
		每次添加元素 r,会将 r 做为 head, 原 head 做为了 r 的 next, 删除就元素没有必要说了吧
	1. 经内存压力测试和 ReferenceQueue 队列回收情况
		A. SoftReference:
			a. 发生 Full GC 时年轻代减少的空间，几乎都跑到老年代了，说明 SoftReference 的实例都跑到老年代了，而且多少 Full GC 后老年代也会减少，
				说明 SoftReference 被回收了
			b. Debug + 日志观察：java.lang.ref.ReferenceQueue#enqueue 添加元素时是与GC之后
			c. 有个疑问如果不手动 remove 队列里的对象不会堆积导致内存泄露么？不是的，即便不传入 ReferenceQueue 队列，还是会内存溢出，因为
			  必须要 list.add(WeakReference), 不解释这是前提
			   粗看网上说的 Pending 队列，Reference 实例几种态度的东东，感觉不太对，不细究了
		B. WeakReference:
			a. GC 是 SoftReference 的一半，而且没有 Full GC,而且每次GC后都能从队列出拿到几乎全部创建的WeakReference对应，说明都回收了呗
			b. 通过日志和调试也不能得出：SoftReference 内存不够时回收, WeakReference 每次gc都回收的结论，但是可以得出GC时对 WeakReference 
			回收的力度要大于 SoftReference			
		C. PhantomReference:
			程序很容易就 OutOfMemoryError, 说明它的回收力度远低于前两者呀, SoftReference 再不ji, Full GC 多，也没让程序挂呀
			测试(对象大小*对象个数≈整heap)发现 PhantomReference 压根就不清除, 与文档所说对得上
		D. SoftReference,WeakReference 这两种 reference，能get到值的和队列里(这三种 reference 队列里 reference.get() 都是 null)的个数之和
		  是精准等于总 reference 个数的 看个例子吧，但是根据这个例子我还是没看出来 SoftReference 这种机制的必要性，如果知道对象该做清理
		  直接清理不就完了么，难道只是为了代码解耦，不写 finally? 不是的, 是不想清理而被迫清理的
			public class ResourceCloseDeamon extends Thread {
				private static ReferenceQueue QUEUE = new ReferenceQueue();
				//保持对 reference 的引用,防止 reference 本身被回收
				private static List<Reference> references = new ArrayList<>();
				@Override
				public void run() {
					this.setName("ResourceCloseDeamon");
					while (true) {
						ResourcePhantomReference reference = (ResourcePhantomReference) QUEUE.remove();
						reference.cleanUp();// 不用关心
						references.remove(reference);// 不 remove 就会内存溢出的
					}
				}
				public static void register(Object referent, List<Closeable> closeables) {
					references.add(new ResourcePhantomReference(referent,QUEUE,closeables));
				}
			}
			再补一句源码中文档注释 
			Unlike soft and weak references, phantom references are not automatically cleared by the garbage collector as they are enqueued.  An
			object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable.
	2. 有必要知道一下有个 java.util.WeakHashMap 这东西
	3. 把这几个 Reference 的源码注释读一读
================================ DirectByteBuffer 提交 ================================
1、Cleaner 会与一个 Runnable 绑定, 注意这可不是一个线程啊
ByteBuffer.allocateDirect 方式创建的 都会带一个 Cleaner, 创建 Cleaner 时传入 this 说明 Cleaner 的 reference 就是 DirectByteBuffer 对象呀
如果 ((DirectBuffer) buffer).cleaner().clean(); 不这样主动释放内存, 就只在等 PhantomReference 机制清理 DirectByteBuffer 对象时被调用 clean 了
DirectByteBuffer 对象是有强引用的吧, 所以也不必担心被回收, 强引用丢了 PhantomReference 机制会起作用了呀, 所以这是 PhantomReference 使用的精典场景
2、堆外内存本质就这两个方法，当然里面还有一些
long pointer = unsafe.allocateMemory(1024 * 1024 * 200);    unsafe.getByte(pointer + 1);    unsafe.freeMemory(pointer);
如果一直没有 freeMemory 则会报错：Process finished with exit code 137 (interrupted by signal 9: SIGKILL), 好像跟 jdk 版本有关,jdk6: OutOfMemoryError 本质是内存溢出导致
3、DirectByteBuffer 内没有一个 byte[] 相关的属性, 当然不能有啊, 有就是在堆内了

public abstract class Buffer {
    private int mark = -1;
    private int position = 0;
    private int limit;
    private int capacity;
    long address;
	// 围绕这几个属性有什么方法想也想得到吧
}
public abstract class ByteBuffer extends Buffer implements Comparable<ByteBuffer>{
    final byte[] hb;                  // Non-null only for heap buffers
    final int offset;
    boolean isReadOnly;                 // Valid only for heap buffers
    ByteBuffer(int mark, int pos, int lim, int cap, byte[] hb, int offset) {
        super(mark, pos, lim, cap);
        this.hb = hb;
        this.offset = offset;
    }
    public static ByteBuffer allocateDirect(int capacity) {
        return new DirectByteBuffer(capacity);
    }
    public static ByteBuffer allocate(int capacity) {
        return new HeapByteBuffer(capacity, capacity);
    }
    public static ByteBuffer wrap(byte[] array, int offset, int length){
        return new HeapByteBuffer(array, offset, length);
    }
    public static ByteBuffer wrap(byte[] array) {
        return wrap(array, 0, array.length);
    }
    public abstract ByteBuffer slice();
    public abstract ByteBuffer duplicate();
    public abstract ByteBuffer asReadOnlyBuffer();
    public abstract byte get();
    public abstract ByteBuffer put(byte b);
    public final byte[] array() {
        return hb;
    }
}
class HeapByteBuffer extends ByteBuffer {
	HeapByteBuffer(int cap, int lim) { super(-1, 0, lim, cap, new byte[cap], 0); }
    public ByteBuffer slice() {
        return new HeapByteBuffer(hb, -1, 0, this.remaining(), this.remaining(), this.position() + offset);
    }
    protected int ix(int i) { return i + offset; }
    public byte get() { return hb[ix(nextGetIndex())]; }
    public ByteBuffer get(byte[] dst, int offset, int length) {
        System.arraycopy(hb, ix(position()), dst, offset, length);
        position(position() + length);
        return this;
    }
    public ByteBuffer put(byte x) {
        hb[ix(nextPutIndex())] = x;
        return this;
    }
    public ByteBuffer put(byte[] src, int offset, int length) {
        System.arraycopy(src, offset, hb, ix(position()), length);
        position(position() + length);
        return this;
    }
}
class DirectByteBuffer extends MappedByteBuffer implements DirectBuffer{
    protected static final Unsafe unsafe = Bits.unsafe();
    private static final long arrayBaseOffset = (long)unsafe.arrayBaseOffset(byte[].class);
    protected static final boolean unaligned = Bits.unaligned();
    private final Object att;
    public Object attachment() { return att; }
    private static class Deallocator implements Runnable {
        private static Unsafe unsafe = Unsafe.getUnsafe();
        private long address;
        private long size;
        private int capacity;
        private Deallocator(long address, long size, int capacity) {
            assert (address != 0);
            this.address = address;
            this.size = size;
            this.capacity = capacity;
        }
        public void run() {
            unsafe.freeMemory(address);
            address = 0;
            Bits.unreserveMemory(size, capacity);
        }
    }
    private final Cleaner cleaner;
    public Cleaner cleaner() { return cleaner; }// ((DirectBuffer) buffer).cleaner().clean(); 调用者可以这样释放内存
    DirectByteBuffer(int cap) { // package-private
        super(-1, 0, cap, cap);
        boolean pa = VM.isDirectMemoryPageAligned();
        int ps = Bits.pageSize();
        long size = Math.max(1L, (long)cap + (pa ? ps : 0));
        Bits.reserveMemory(size, cap);// 这里岂不是很重要
        long base = 0;
		base = unsafe.allocateMemory(size);
        unsafe.setMemory(base, size, (byte) 0);
        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));// 传入 this 说明 Cleaner 的 reference 就是 DirectByteBuffer 对象呀
        att = null;
    }
    public ByteBuffer slice() {
        int pos = this.position();
        int lim = this.limit();
        assert (pos <= lim);
        int rem = (pos <= lim ? lim - pos : 0);
        int off = (pos << 0);
        assert (off >= 0);
        return new DirectByteBuffer(this, -1, 0, rem, rem, off);
    }
    private long ix(int i) { return address + ((long)i << 0); }
    public byte get(int i) { return ((unsafe.getByte(ix(checkIndex(i))))); }
    public ByteBuffer get(byte[] dst, int offset, int length) {
        if (((long)length << 0) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
            checkBounds(offset, length, dst.length);
            int pos = position();
            int lim = limit();
            assert (pos <= lim);
            int rem = (pos <= lim ? lim - pos : 0);
			Bits.copyToArray(ix(pos), dst, arrayBaseOffset, (long)offset << 0, (long)length << 0);
            position(pos + length);
        } else {  super.get(dst, offset, length); }
        return this;
    }
    public ByteBuffer put(byte x) {
        unsafe.putByte(ix(nextPutIndex()), ((x)));
        return this;
    }
    public ByteBuffer put(ByteBuffer src) {
        if (src instanceof DirectByteBuffer) {
            DirectByteBuffer sb = (DirectByteBuffer)src;
            int spos = sb.position();
            int slim = sb.limit();
            assert (spos <= slim);
            int srem = (spos <= slim ? slim - spos : 0);
            int pos = position();
            int lim = limit();
            assert (pos <= lim);
            int rem = (pos <= lim ? lim - pos : 0);
            unsafe.copyMemory(sb.ix(spos), ix(pos), (long)srem << 0);
            sb.position(spos + srem);
            position(pos + srem);
        } else if (src.hb != null) {
            int spos = src.position();
            int slim = src.limit();
            assert (spos <= slim);
            int srem = (spos <= slim ? slim - spos : 0);
            put(src.hb, src.offset + spos, srem);
            src.position(spos + srem);
        } else {
            super.put(src);
        }
        return this;
    }
    public ByteBuffer put(byte[] src, int offset, int length) {
        if (((long)length << 0) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
            checkBounds(offset, length, src.length);
            int pos = position();
            int lim = limit();
            assert (pos <= lim);
            int rem = (pos <= lim ? lim - pos : 0);
			Bits.copyFromArray(src, arrayBaseOffset, (long)offset << 0, ix(pos), (long)length << 0);
            position(pos + length);
        } else {
            super.put(src, offset, length);
        }
        return this;
    }
    public boolean isDirect() {
        return true;
    }
    private double getDouble(long a) {
        if (unaligned) {
            long x = unsafe.getLong(a);
            return Double.longBitsToDouble(nativeByteOrder ? x : Bits.swap(x));
        }
        return Bits.getDouble(a, bigEndian);
    }
    private ByteBuffer putDouble(long a, double x) {
        if (unaligned) {
            long y = Double.doubleToRawLongBits(x);
            unsafe.putLong(a, (nativeByteOrder ? y : Bits.swap(y)));
        } else {
            Bits.putDouble(a, x, bigEndian);
        }
        return this;
    }
}
public abstract class java.nio.MappedByteBuffer extends ByteBuffer {
	private final FileDescriptor fd;// 我只想说这里很重要
    MappedByteBuffer(int mark, int pos, int lim, int cap, FileDescriptor fd) { super(mark, pos, lim, cap); this.fd = fd; }
}
public class sun.misc.Cleaner extends PhantomReference<Object> {
	private static final ReferenceQueue<Object> dummyQueue = new ReferenceQueue();
    private final Runnable thunk;
    private Cleaner(Object var1, Runnable var2) { super(var1, dummyQueue); this.thunk = var2; }
    public static Cleaner create(Object var0, Runnable var1) {
        return var1 == null ? null : add(new Cleaner(var0, var1));
    }
    private static synchronized Cleaner add(Cleaner var0) { // 哇原来还有个静态链表啊, 干什么用呢
        if (first != null) { var0.next = first; first.prev = var0; }
        first = var0; return var0;
    }
    public void clean() {
        if (remove(this)) { try { this.thunk.run(); } catch (final Throwable var2) { System.exit(1); } }
    }
}
class java.nio.Bits {
	// initialization if it is launched with "-XX:MaxDirectMemorySize=<size>". 这注释已经... 我验证过了
    private static volatile long maxMemory = VM.maxDirectMemory();
    private static final AtomicLong reservedMemory = new AtomicLong();
    private static final AtomicLong totalCapacity = new AtomicLong();
    private static final AtomicLong count = new AtomicLong();
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static byte _get(long a) { return unsafe.getByte(a); }
    private static void _put(long a, byte b) {  unsafe.putByte(a, b); }
    private static int pageSize = -1;
	static int pageSize() {
        if (pageSize == -1) pageSize = unsafe().pageSize();
        return pageSize;
    }
    private static volatile long maxMemory = VM.maxDirectMemory();
    static void reserveMemory(long size, int cap) {
        if (!memoryLimitSet && VM.isBooted()) {
            maxMemory = VM.maxDirectMemory(); memoryLimitSet = true;
        }
        if (tryReserveMemory(size, cap)) {  return; }// tryReserveMemory 还有内存就 return 了
        final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();
        while (jlra.tryHandlePendingReference()) { // 这里还挺玄妙的呢, 有精力看一下
            if (tryReserveMemory(size, cap)) { return; }
        }
        System.gc();// 这里好重要, 主要是触发 cleaner 被收集吧。如果 -XX:+DisableExplicitGC, 会报 OOM(Direct buffer memory), 当然前提也是 DirectByteBuffer 引用被释放, 如果不释放也一点作没有呀
        boolean interrupted = false;
		long sleepTime = 1;
		int sleeps = 0;
		while (true) {
			if (tryReserveMemory(size, cap)) { return; }// 死循环申请内存, 其实只能待 Cleaner 释放了
			if (sleeps >= MAX_SLEEPS) { break; }
			if (!jlra.tryHandlePendingReference()) {
				Thread.sleep(sleepTime); sleepTime <<= 1; sleeps++; // 居然也有 sleep 这种雷人操作
			}
		}// -XX:MaxDirectMemorySize=100M 这个值真的好准, 如果真的用到了 100M, 即 DirectByteBuffer 引用不释放, 真就 OOM
		throw new OutOfMemoryError("Direct buffer memory");
    }
	private static boolean tryReserveMemory(long size, int cap) { // 这方法好像是做个统计
        // -XX:MaxDirectMemorySize limits the total capacity rather than the actual memory usage, which will differ when buffers are page aligned.
        long totalCap;
        while (cap <= maxMemory - (totalCap = totalCapacity.get())) {
            if (totalCapacity.compareAndSet(totalCap, totalCap + cap)) { reservedMemory.addAndGet(size); count.incrementAndGet(); return true; }
        }
        return false;
    }
	static void copyFromArray(Object src, long srcBaseOffset, long srcPos, long dstAddr, long length) {
        long offset = srcBaseOffset + srcPos;
        while (length > 0) {
            long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : length;
            unsafe.copyMemory(src, offset, null, dstAddr, size);
            length -= size; offset += size; dstAddr += size;
        }
    }
    static void copyToArray(long srcAddr, Object dst, long dstBaseOffset, long dstPos, long length) {
        long offset = dstBaseOffset + dstPos;
        while (length > 0) {
            long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : length;
            unsafe.copyMemory(null, srcAddr, dst, offset, size);
            length -= size; srcAddr += size; offset += size;
        }
    }
}
----
    public static Unsafe getUnsafe() throws NoSuchFieldException, IllegalAccessException {
        Field field = Unsafe.class.getDeclaredField("theUnsafe");
        field.setAccessible(true);
        Unsafe unsafe = (Unsafe)field.get(null);
//            Unsafe unsafe = (Unsafe)field.get(Unsafe.class);
        return unsafe;
    }
----

================================ Finalizer ================================
1、jmap -histo:live 16955, 占用内存较多的是 java.lang.ref.Finalizer 和对应类, 而没有 finalize 方法时则没问题
final class java.lang.ref.Finalizer extends FinalReference<Object> {// 用来保证finalize只被调用一次, 成本真是很高啊
	private static ReferenceQueue<Object> queue = new ReferenceQueue<>();// 这个 queue 好熟悉吧
    private Finalizer(Object finalizee) {
        super(finalizee, queue);
        add();
    }
    static void register(Object finalizee) { /* Invoked by VM */ // 也可以说是被 Object.init 中调用的, init 当然是不存的, 即对象初始化之前
        new Finalizer(finalizee);
    }
	private void runFinalizer(JavaLangAccess jla) {
		if (hasBeenFinalized()) return;
		remove();
		Object finalizee = this.get();// 这就是那个对象
		if (finalizee != null && !(finalizee instanceof java.lang.Enum)) {
			jla.invokeFinalize(finalizee);// 这不用管了就是调一下 finalize 方法
			finalizee = null;// 不置 null 也没事吧, 因为 this 都被 remove 了, 引用都断开了
		}
        super.clear();
    }
	private static class FinalizerThread extends Thread {
        private volatile boolean running;
        FinalizerThread(ThreadGroup g) { super(g, "Finalizer"); }
        public void run() {
            if (running) return;
            while (!VM.isBooted()) { VM.awaitBooted(); }
            final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
            running = true; // 就是通过这货来表达 finalize 可能不被调用的吧
            for (;;) {
				Finalizer f = (Finalizer)queue.remove(); // 什么时候加进去不用说了吧
				f.runFinalizer(jla);// 这是起点
            }
        }
    }
	static {
        ThreadGroup tg = Thread.currentThread().getThreadGroup();
        for (ThreadGroup tgn = tg; tgn != null; tg = tgn, tgn = tg.getParent());
        Thread finalizer = new FinalizerThread(tg);
        finalizer.setPriority(Thread.MAX_PRIORITY - 2);
        finalizer.setDaemon(true);
        finalizer.start();
    }
}
class java.lang.ref.FinalReference<T> extends Reference<T> {
    public FinalReference(T referent, ReferenceQueue<? super T> q) { super(referent, q); }
}
================================ ConcurrentHashMap, ConcurrentLinkedQueue, LinkedBlockingQueue,  ================================
主要是用到了 sun.misc.Unsafe 的 getObjectVolatile compareAndSwapObject putObjectVolatile 三个方法
static final class Segment<K,V> extends ReentrantLock implements Serializable {}
ConcurrentHashMap 在 jdk1.7 中最重要的是 ReentrantLock, lock 就是对此 Segment 加锁
原来真有 ConcurrentLinkedQueue 这个东东啊, 没有加锁, 完全是通过 cas 实现的
HashMap 的 resize split 方法, 成环问题  也要看下

public interface java.util.Queue<E> extends Collection<E> {
    boolean add(E e);
    boolean offer(E e);
    E remove();
    E poll();
    E element();
    E peek();
}
public interface java.util.concurrent.BlockingQueue<E> extends Queue<E> {
    boolean add(E e);
    boolean offer(E e);
    void put(E e) throws InterruptedException;
    E take() throws InterruptedException;
    E poll(long timeout, TimeUnit unit) throws InterruptedException;
    boolean remove(Object o);
}
public class LinkedBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, java.io.Serializable {
    private final ReentrantLock takeLock = new ReentrantLock();
    private final Condition notEmpty = takeLock.newCondition();
    private final ReentrantLock putLock = new ReentrantLock();
    private final Condition notFull = putLock.newCondition();
}

public class java.util.Stack<E> extends Vector<E> {
    public Stack() {}
    public E push(E item) { addElement(item); return item; }
    public synchronized E pop() {
        obj = peek();
        removeElementAt(len - 1);
        return obj;
    }
    public synchronized E peek() {
        int len = size();
        return elementAt(len - 1);
    }
    public boolean empty() { return size() == 0; }
}

================================ 动态代理 ================================
java 的动态代理要实现接口是必不可少的(本质就是面向接口的), 除非动态代理类是被代理类的子类, 要不然怎么可以[被代理类].[方法]呢。而 cglib 
代理是用子类的方式, CGLIB 底层：使用字节码处理框架 ASM，来转换字节码并生成新的类
说白了就是 java 动态代理做不够完美, 做成像 cglib 那种好像也没太大难度吧

public class DynamicProxyTest {
    interface IHello {void sayHello();}
    static class Hello implements IHello {
        public void sayHello() {
            System.out.println("hello world");
        }
    }
    static class DynamicProxy implements InvocationHandler {
        Object orginalObj;
        public DynamicProxy(Object orginalObj){
            this.orginalObj = orginalObj;
        }
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {// 此 method 是接口的 method
            System.out.println("welcome  "+proxy.getClass().getName());// proxy 就是代理类的实例其实真没啥用
            return method.invoke(orginalObj, args);
        }
    }
    public static void main(String[] args) {
//		这个很有用哈，生成类在 [工程]/[包路径]/$Proxy0.class
//      System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");
        Hello h = new Hello();// 其实要不是因为真的想要执行此实现类中的方法(即 invoke 方法中不用他的话), 他也不是必须传的
        IHello hello = (IHello) Proxy.newProxyInstance(h.getClass().getClassLoader(), h.getClass().getInterfaces(), new DynamicProxy(h));
        hello.sayHello();
    }
}
final class $Proxy0 extends Proxy implements DynamicProxyTest.IHello {
    private static Method m3;
    public $Proxy0(InvocationHandler paramInvocationHandler) {
		// paramInvocationHandler 就是 DynamicProxy 的实例,生成字节码类后，反射 Proxy0 实例时传进去的应该
        super(paramInvocationHandler);
    }
    public final void sayHello() {
        this.h.invoke(this, m3, null);
    }
    static {
        m3 = Class.forName("other.DynamicProxyTest$IHello").getMethod("sayHello", new Class[0]);
    }
}
public class Proxy implements java.io.Serializable {
    protected Proxy(InvocationHandler h) {
        this.h = h;
    }
}
  字节码是在这个方法中生成的，sun.misc.ProxyGenerator#generateProxyClass,调用自然是从 Proxy.newProxyInstance 进来的, 真不不太复杂。动态代理
包括反射在内真正的黑盒应该是 method.invoke 这个方法
--------
public class MyMethodInterceptor implements MethodInterceptor {
    public Object intercept(Object obj, Method method, Object[] arg, MethodProxy proxy) throws Throwable {
        System.out.println("Before:" + method);
        Object object = proxy.invokeSuper(obj, arg);
        System.out.println("After:" + method);
        return object;
    }
}
public class UserServiceImpl {
    public void add() {
        System.out.println("This is add service");
    }
    public void delete(int id) {
        System.out.println("This is delete " + id );
    }
}
public class CglibDemo {
	public static void main(String[] args) {
		//System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/home/tyx/cglib");
		Enhancer enhancer = new Enhancer();
		enhancer.setSuperclass(UserServiceImpl.class);
		enhancer.setCallback(new MyMethodInterceptor());
		UserServiceImpl userService = (UserServiceImpl)enhancer.create();
		userService.add();
	}
}
--------
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
	protected transient int modCount = 0;
	public Iterator<E> iterator() {
		return new Itr();
	}
	private class Itr implements Iterator<E> {
		int cursor = 0;// 迭代器说简单点就一个下标属性
		int expectedModCount = modCount;
		public boolean hasNext() {
			return cursor != size();
		}
		public E next() {
			int i = cursor;
			E next = get(i);
			cursor = i + 1;
			return next;
		}
        public void remove() { // 没有 add 方法哈
            checkForComodification();
			AbstractList.this.remove(lastRet);
			if (lastRet < cursor)
				cursor--;
			lastRet = -1;
			expectedModCount = modCount;// 这是灵魂
        }
		final void checkForComodification() {
			if (modCount != expectedModCount) throw new ConcurrentModificationException();
        }

	}
}
================================ 内部类 ================================
public class OuterDemo {
    public static void main(String[] args) {
        OuterDemo outerDemo = new OuterDemo();
        InnerDemo innerDemo = outerDemo.new InnerDemo();
        innerDemo.iff();
    }
    class InnerDemo{
        public void iff(){
            of();
        }
    }
    public void of(){
        System.out.println(this);//OuterDemo@511d50c0
    }
}
================================ final 内部类 ================================
public class DemoOne {
    List<InterOne> list = new ArrayList<>();
    public static void main(String[] args) {
        DemoOne demoOne = new DemoOne();
        Ktring ktring = new Ktring();
        demoOne.fn(ktring);
        ktring = new Ktring();
        demoOne.print();
    }
    public void fn(Ktring str){// jdk1.7:final Ktring str, 而且除了这里其它地方没有区别, 即调用 fn 时传参不需要 final
        InterOne io = new InterOne() {
            @Override
            public Ktring ff() {
                System.out.println(str);
				// str = new Ktring(); // 虽然 jdk1.8 没加 final 但是这样干也是不允许的, 既然是值拷贝为什么不允许呢
                return str;
            }
        };
        io.ff();
        list.add(io);
    }
    public void print(){
        for (InterOne io : list){
            io.ff();
        }
    }
}
class Ktring{}

jdk1.7 与 jdk1.8 反编译都这样
class other.mypackage.DemoOne$1 implements other.mypackage.InterOne {
  final other.mypackage.Ktring val$str;
  final other.mypackage.DemoOne this$0;
  other.mypackage.DemoOne$1(other.mypackage.DemoOne, other.mypackage.Ktring);
  public other.mypackage.Ktring ff();
}
其实, 由于值拷贝, 所以加不加 final 有什么区别呢, 无论内部类外还是内部类内, 这个引用可以随便换啊
网友: 详细点说，之所以要加final，斗胆站在一个语言设计者的角度想，其根本原因或许是这样的：Java父：按照我之前的设计，在匿名内部类里面对外部局部变量的
修改实际上是无法生效的，那既然无法生效，我就不让他们修改了呗，有什么办法呢？Java母：你说的这种情况下，不管外部局部变量是不是final的，它在匿名内部类
的作用域内，所实际表现出来的现象本质上就是final的，所以，要不给它约束个final？

================================ 原子类 ================================
fieldUpdater = AtomicLongFieldUpdater.newUpdater(CASBasedCounter.class, "count");// private volatile long count; 注意 count 必需是 volatile, 否则这行代码执行报错
fieldUpdater.compareAndSet(this, oldValue, newValue);


