通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。
内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：
1. 保证特定操作的执行顺序。
2. 影响某些数据（或则是某条指令的执行结果）的内存可见性。
-- 我去, 这两条不就是对标 volicate 么

1、大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，
避开获取下一条指令所需数据时造成的等待
2、除了处理器，常见的Java运行时环境的JIT编译器也会做指令重排序操作，即生成的机器指令与字节码指令顺序不一致。
--------
编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
指令级并行的重排序：如果不存l在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。但是，可以通过插入特定类型的Memory Barrier来禁止特定类型的
编译器重排序和处理器重排序
--好像是不是说有三种级别的重排序, 编译器、runtime和处理器

数据依赖性：如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。
-- 想想单例的场景, Object a = new Object(); 开辟完对象内存空间之后, 赋值操作和初始化操作是可以重排序的么

Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程
都能读取到这些数据的最新版本。
--对这句话,我难免有个疑问, 每个 cpu 执行时是无法干预其它 cup 执行的吧, 上面这句话怎么做到的呢? 我目测一下应该是这样的
volicate int a; cpu1: a=1; 在这个赋值指令执行之间, 就去清空其它 cpu 中 a 的缓存, 但是 cpu1 的缓存和主存的先后顺序是咋样的记不清了

如果一个变量是volatile修饰的，JMM会在写入这个字段之后插进一个Write-Barrier指令，并在读这个字段之前插入一个Read-Barrier指令。这意味着，如果写入一个
volatile变量，就可以保证：
一个线程写入变量a后，任何线程访问该变量都会拿到最新值。
在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。因为Memory Barrier会刷出cache中的所有先前的写入。
--意思是本 cpu 缓存同步到主存中, 但是"清空"其它 cpu 缓存还是同步?


内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。
内存屏障可以被分为以下几种类型
LoadLoad 屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
StoreStore 屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
LoadStore 屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
StoreLoad 屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。        在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。
--我觉得内存屏障是套规范, 硬件提供商在实现这个, jvm 遇到 volicate 加入一个内存屏障就行了. 我突然感觉到了, unsafe 下的那些原子操作, 应该就是依赖这些
东东吧, 而且 cas 底层是不是也是类似于这些, 细想一下, 在 StoreLoad 支持的前提下, 我还是没想明白

compareAndSwapInt就是借助C来调用CPU底层指令实现的。下面从分析比较常用的CPU（intel x86）来解释CAS的实现原理。
程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀, 带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存
-- 本质就是个锁, 操作系统级别的, 更轻量级的, 发挥一下我的脑洞, 在指令重排序的原则下, 这种锁并不一定把 cpu 锁了, 所以呀性能损失不会太大, 反向印证
了指令重排序的意义. 我又想到一个场景, int a=0; a++; int b=0; b++; 从主存取 a, b 值放入缓存操作可以一块做么, 效率肯定高
--引用[Java多线程编程实战指南 核心篇]P45, CAS 实现原子性与锁实现原子性的方式实质上是相同的, 不同是锁在软件层面实现, CAS 在硬件层面实现, 可以看作 "硬件锁" 
================================================
内存屏障是保证锁实现线程同步机制的一个主力
锁保证可见性的过程：获得锁后刷新处理器缓存，保证当前线程读取到上个线程对共享变量做的跟新，释放锁后冲刷处理器缓存，保证当前对共享变量做的更新能被下个执行线程读取到。而这两个动作是Java虚拟机借助底层的内存屏障来实现的
内存屏障仅针对内存读写操作指令，是被插到两个指令之间使用的，作用是禁止编译器，处理器重排序从而保证有序性，因为保证有序性的同时会刷新处理器缓存/冲刷处理器缓存，所以同时保证了可见性

八 种原子操作：
lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；
unlock(解锁):作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；
load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本
use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；
assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；
store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；
write（操作）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

======================================================
引述一段话:(https://blog.csdn.net/wypblog/article/details/101731752)
共享内存：比如动态库只需要在内存中存储一份，然后将它映射到不同进程的虚拟地址空间中，让进程觉得自己独占了这个文件。
进程间的内存共享也可以通过映射同一块物理内存到进程的不同虚拟地址空间来实现共享
--给我的启发是, 进程间通过文件共存内存/进程间通信, 道理上是不是一样的

为什么划分用户态内核态：
  裸机时代，应用程序和硬件操作糅合在一起，应用程序和硬件操作高度耦合的框图，上述代码一般很难有良好的代码互用和移植性。往往从一个平台移植到另一个平台，
甚至是同一平台不同硬件配置都要求很大的代码改动，另外从应用层来说，应用与驱动高度耦合，应用程序也几乎难以移植，甚至说是没有应用程序概念，
原因在于应用与驱动的纠缠不清
https://wenku.baidu.com/view/7564a0db77a20029bd64783e0912a21614797fbf.html
--自行脑补一下, 现代程序是没有硬件操作的吧, 说明确实有个内核进程或内样接口帮我们做这件事, 举个例子, java 之间的方法调用, 也是值拷贝么, 所以用户态往
内核态传数据就说得通了。进一步比喻一下，用户空间和内核空间相当于两个方法栈, 内核就是个方法/函数
======================================================
cassandra:
认每个节点产生256个token(令牌)范围
key 怎么找到另外两个节点的位置, 好像是顺延的(是不是类似 kafka)
使用虚拟节点的好处(me):
  a. 添加移除节点后无需重新平衡集群负载
  b. 更好的负载均衡
======================================================
在64位系统中jvm分配的内存大小不受限制，可以分配超过实际可用内存的空间，但当可用内存用尽时将使用虚拟内存/swap区，从而导致系统出现抖动（thrashing）现象，
系统性能将明显下降。当分配空间超过实际内存非常大时程序启动过程也将变得十分缓慢
--但是经我测试其实是不行的, 
-Xmx8g -Xms8g   --> Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000005c0000000, 5726797824, 0) failed; error='Cannot allocate memory' (errno=12)

