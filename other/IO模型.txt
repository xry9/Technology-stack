同步IO：应用程序主动向内核查询是否有可用数据，如果有自己负责把数据从内核copy到用户空间。
异步IO：应用程序向内核发起读数据请求需要：（1）告诉内核数据存放位置（2）注册回调函数，当内核完成数据copy后调用回调通知应用程序取数据。
同步/异步最大区别：数据从内核空间到用户空间的copy动作由应用程序自己完成。而异步IO则是注册回调函数并告知内核用户空间缓冲区存放地址，
数据copy由内核完成

阻塞IO缺点：线程在无数据可用时候会被阻塞，每个线程只监听自己关心的文件句柄。

非阻塞IO缺点：read操作可能读取不到数据。多路复用IO模型可以很好解决上述缺点。

多路复用IO解决上述问题的思路：（1）用一个线程（Selector）监听所有已注册的文件句柄，（2）只有当监听的文件句柄有可用数据时才通知应用程序去读取数据。
--------
比如tomcat 采用的传统的BIO（同步阻塞IO模型? 有待考证）+ 线程池 模式： 这个模式适合活动连接数不是特别高的（连接<1000）
讲一下NIO模式， 所有的IO模式都分为两个阶段， 一是等待就绪（准备数据）也就是从网卡copy到内核缓存区（从内核缓存区copy到网卡）， 二是真正的操作（读，写） 也就是从内核缓存区copy到用户地址空间；
前者（等待就绪）对于BIO模式是阻塞的， 对于NIO，AIO都是非阻塞的；
后者（读写处理）对于BIO，NIO都是阻塞的， 但是AIO不是阻塞的，完全是异步的， 在这个处理阶段，一般都是多核处理器，如果能够利用多核心进行I/O，无疑对效率会有更大的提高，我们可以采用线程池的模式，多个线程去处理 ，比如tomcat 的 nio就是采用此模式， 但是redis是单线程处理的，因为redis完全是内存操作，不会出现超时的现象；

--------
io操作分为两部分，发起io请求，和io数据读写。阻塞、非阻塞主要是针对线程发起io请求后，是否立即返回来定义的，立即返回称为非阻塞io，否则称为阻塞io。
同步、异步主要针对io数据读写来定义的，读写数据过程中不阻塞线程称为异步io，否则，称为同步io。
BIO:线程发起io请求后，一直阻塞(阻塞io)，直到数据就绪后，用户线程将数据写入socket空间，或从socket空间读取数据（同步）。

NIO:线程发起io请求后，立即返回（非阻塞io）。用户线程不阻塞等待，但是，用户线程要定时轮询检查数据是否就绪，当数据就绪后，用户线程将数据从用户空间写入socket空间，或从socket空间读取数据到用户空间（同步）
IO多路复用（NIO）：上述NIO实现中，需要用户线程定时轮训，去检查IO数据是否就绪，占用应用程序线程资源。IO多路复用模型中，将检查IO数据是否就绪的任务，交给系统级别的select或poll模型，由系统进行监控，减轻用户线程负担。

