全局聚合：kafkaStream 处理100w(每条消息52字节)，30s没有问题，如果参数调节好20s应该可以搞定，而sparkStreaming一分钟都处理不了。
	redids处理起来快得简直可以忽略,只要3.1s（Pipeline）

非全局聚合：sparkStreaming 15s处理400w延迟还是很大的

=========================================== mysql ===========================================
物理机mysql：
1、10个字段，字段类型都是字符串，每个字段字14个字节，没有主键索引，表文件大小大概是写入数据大小的1.3倍
	批量写10w条(1w条batch一次)，前期89s（8g,4core虚拟机中rpm包版本70s，percona版本60s），超过1000w条再测则是92s。读性能（navicate）：10w行：0.14s,20w行：0.26s,40w行：0.46s，虚拟机40w行内为0.3s
		在navicate中写怎么2s不到？？？？
S	使用多线程后，时间比例为 379881(1):149707(4):68962(16)，再多开，最后完成的线程时间减小不大，再多甚至会略有增加（4,16为非batch写入，因为本机网络较好batch故提升不大）
2、同样10个字段，不同的是一个是自增类型主键，一个是时间戳，并对两个字段建是索引，表文件大小大概是写入数据大小的1.76倍
	批量写10w条(1w条batch一次)，前期110s，超过1000w条再测则是230s。索引字段的查询几乎同主键查询一样快（0.014s），其它字段8s
3、同样的字段个数个字段长度，向hbase中插入，7.5s(8g,4core虚拟机，内存1g时，10s左右)，如果预先分好区会在7s之内
4、同样的字段个数个字段长度，4000w条，第一次get永远都是320ms左右，之后少于2000次时0.6ms左右，几千到100w次时每次在2ms以内
5、通过scan.setCaching(10);证明，网络带宽越大，rpc请求次数多少对结果影响越大
4、同样大小数据redis用39s，用Pipeline，只要5.5s