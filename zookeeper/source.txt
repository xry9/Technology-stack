public class org.apache.zookeeper.server.quorum.QuorumPeerMain {
	public static void main(String[] args) {
		QuorumPeerMain main = new QuorumPeerMain();
		main.initializeAndRun(args);
        System.exit(0);
    }
	protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServerException {
        QuorumPeerConfig config = new QuorumPeerConfig();
		runFromConfig(config);
    }
	public void runFromConfig(QuorumPeerConfig config) throws IOException, AdminServerException {
		quorumPeer = getQuorumPeer();
		quorumPeer.initialize();
		quorumPeer.start();
		quorumPeer.join();
	}	
    protected QuorumPeer getQuorumPeer() throws SaslException {
        return new QuorumPeer();
    }
}

public class org.apache.zookeeper.server.quorum.QuorumPeer extends ZooKeeperThread implements QuorumStats.Provider {
	public QuorumPeer() throws SaslException {
        initialize();
    }
	public synchronized void start() {
		loadDataBase();
		startServerCnxnFactory();
		startLeaderElection();
		super.start();
	}
	synchronized public void startLeaderElection() {
		if (getPeerState() == ServerState.LOOKING) {
			currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());
		}
		if (electionType == 0) {
			udpSocket = new DatagramSocket(getQuorumAddress().getPort());
			responder = new ResponderThread();
			responder.start();
		}
		this.electionAlg = createElectionAlgorithm(electionType);// FastLeaderElection
	}
}
public class org.apache.zookeeper.server.quorum.FastLeaderElection implements Election {
	LinkedBlockingQueue<ToSend> sendqueue;
    LinkedBlockingQueue<Notification> recvqueue;
	public Vote lookForLeader() throws InterruptedException {
		HashMap<Long, Vote> recvset = new HashMap<Long, Vote>();
		HashMap<Long, Vote> outofelection = new HashMap<Long, Vote>();
		int notTimeout = finalizeWait;
		synchronized(this){
			logicalclock.incrementAndGet();
			updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());
		}
		sendNotifications();
		while ((self.getPeerState() == ServerState.LOOKING) && (!stop)){
			Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);
			switch (n.state) {
				case LOOKING:
					if (n.electionEpoch > logicalclock.get()) {
						logicalclock.set(n.electionEpoch);
						recvset.clear();
						if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {
							updateProposal(n.leader, n.zxid, n.peerEpoch);
						} else {
							updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());
						}
						sendNotifications();
					} else if (n.electionEpoch < logicalclock.get()) {
						break;
					} else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {
						updateProposal(n.leader, n.zxid, n.peerEpoch);
						sendNotifications();
					}
					recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));// 这里是关键
					if (termPredicate(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch))) {
						while((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null){
							if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)){
								recvqueue.put(n);
								break;
							}
						}
						if (n == null) {
							self.setPeerState((proposedLeader == self.getId()) ? ServerState.LEADING: learningState());
							Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);
							leaveInstance(endVote);
							return endVote;
						}
					}
					break;
				case OBSERVING:
					break;
				case FOLLOWING:
				case LEADING:
					outofelection.put(n.sid, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));
					if (termPredicate(outofelection, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state)) && checkLeader(outofelection, n.leader, n.electionEpoch)) {
						synchronized(this){
							logicalclock.set(n.electionEpoch);
							self.setPeerState((n.leader == self.getId()) ? ServerState.LEADING: learningState());
						}
						Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);
						leaveInstance(endVote);
						return endVote;
					}
					break;
				default:
					break;
			}
		}
		return null;
	}
	synchronized void updateProposal(long leader, long zxid, long epoch){
		proposedLeader = leader;
		proposedZxid = zxid;
		proposedEpoch = epoch;
	}
	 protected class Messenger {
        class WorkerReceiver extends ZooKeeperThread  {
            public void run() {
                Message response;
                while (!stop) {
					response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);
					Notification n = new Notification();
					long rleader = response.buffer.getLong();
					long rzxid = response.buffer.getLong();
					long relectionEpoch = response.buffer.getLong();                        
					if(!validVoter(response.sid)) {} else {
						n.leader = rleader;
						n.zxid = rzxid;
						n.electionEpoch = relectionEpoch;
						n.state = ackstate;
						n.sid = response.sid;
						n.peerEpoch = rpeerepoch;
						n.version = version;
						n.qv = rqv;
						if(self.getPeerState() == QuorumPeer.ServerState.LOOKING){
							recvqueue.offer(n);
							if((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())){
                                    Vote v = getVote();
                                    QuorumVerifier qv = self.getQuorumVerifier();
                                    ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());
                                    sendqueue.offer(notmsg);
                                }
						} else {
                                Vote current = self.getCurrentVote();
                                if(ackstate == QuorumPeer.ServerState.LOOKING){
                                    QuorumVerifier qv = self.getQuorumVerifier();
                                    ToSend notmsg = new ToSend( ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());
                                    sendqueue.offer(notmsg);
                                }
                        }
					}
                }
            }
        }
	}
	class WorkerSender extends ZooKeeperThread {
		QuorumCnxManager manager;
		public void run() {
			while (!stop) {
				ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS);
				process(m);
			}
		}
		void process(ToSend m) {
			ByteBuffer requestBuffer = buildMsg(m.state.ordinal(), m.leader, m.zxid, m.electionEpoch, m.peerEpoch, m.configData);
			manager.toSend(m.sid, requestBuffer);
		}
	}
	private void sendNotifications() {
        for (long sid : self.getCurrentAndNextConfigVoters()) {
            QuorumVerifier qv = self.getQuorumVerifier();
            ToSend notmsg = new ToSend(ToSend.mType.notification, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, sid, proposedEpoch, qv.toString().getBytes());
            sendqueue.offer(notmsg);
        }
    }

}


public class org.apache.zookeeper.server.quorum.QuorumCnxManager {
	public void addToRecvQueue(Message msg) {
		recvQueue.add(msg);
    }
    public Message pollRecvQueue(long timeout, TimeUnit unit)
       throws InterruptedException {
       return recvQueue.poll(timeout, unit);
    }
	public void toSend(Long sid, ByteBuffer b) {
        if (this.mySid == sid) {
             addToRecvQueue(new Message(b.duplicate(), sid));
        } else { }
    }
	class RecvWorker extends ZooKeeperThread {
        Long sid;
        Socket sock;// 3878, 3888, 3898 这几个端口之间的事情
		final DataInputStream din;
		public void run() {
			threadCnt.incrementAndGet();
			while (running && !shutdown && sock != null) {
				int length = din.readInt();
				byte[] msgArray = new byte[length];
				din.readFully(msgArray, 0, length);
				ByteBuffer message = ByteBuffer.wrap(msgArray);
				Message m = new Message(message.duplicate(), sid);
				addToRecvQueue(m);
			}
		}
    }
	class SendWorker extends ZooKeeperThread {
		Long sid;
		Socket sock;
		RecvWorker recvWorker;
		synchronized void send(ByteBuffer b) throws IOException {
            dout.writeInt(b.capacity());
            dout.write(b.array());
            dout.flush();
        }
		public void run() {
			ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
			if (bq == null || isSendQueueEmpty(bq)) {
			   ByteBuffer b = lastMessageSent.get(sid);
			   if (b != null) {
				   send(b);
			   }
			}
			while (running && !shutdown && sock != null) {
				ByteBuffer b = null;
				ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
				if (bq != null) {
					b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);
				} else {
					break;
				}
				if(b != null){
					lastMessageSent.put(sid, b);
					send(b);
				}
			}
        }
	}
}
===run===249===1===1
===run===249===1===1
===run===249===1===1
===run===249===1===1
===run===249===1===1
===run===249===1===1
===run===249===2===2
===run===249===2===2
===run===249===2===1
===run===249===3===3
===run===249===3===3

===run===249===2===2
===run===249===1===1
===run===249===1===1
===run===249===2===2
===run===249===2===1
===run===249===3===3
===run===249===3===3

===run===249===2===1
===run===249===2===1
===run===249===3===3
===run===249===2===2
===run===249===2===2
===run===249===3===3
===run===249===3===3
===run===249===2===1
===run===249===2===2
